<!DOCTYPE html>
<html>

<head>
    <title>UV</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!-- core three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <!-- lil-gui -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <script>

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // ✅ เปิดใช้งานเงา!
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        // ✅ กล้อง
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 6, 4);
        camera.lookAt(0, 0, 0);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        //Ambient Light
        const ambientLight = new THREE.AmbientLight(0x808080); // แสงสว่างทั่วไป
        scene.add(ambientLight);

        //Directional Light
        const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.9); // แสงทิศทาง
        directionalLight.position.set(10, 5, 10);
        directionalLight.castShadow = true; // ✅ แสงนี้สร้างเงา
        scene.add(directionalLight);

        // ✅ Load environment EXR
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        const exrLoader = new THREE.EXRLoader();
        exrLoader.load('https://chotika47.github.io/myModel/christmas_photo_studio_07_1k.exr', (texture) => {
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.background = envMap;   // background
            scene.environment = envMap;  // reflection

            texture.dispose();           // clear memory
            pmremGenerator.dispose();
        });

        //พื้น
        //load texture
        const textFloor = new THREE.TextureLoader().load('https://chotika47.github.io/myModel/pavement_02_diff_1k.jpg', t => {
            t.wrapS = THREE.RepeatWrapping;
            t.wrapT = THREE.RepeatWrapping;
        });
        //map
        matFloor = new THREE.MeshStandardMaterial({
            map: textFloor
        });
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        //const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const plane = new THREE.Mesh(planeGeometry, matFloor);
        plane.rotation.x = -Math.PI / 2; // หมุนให้เป็นพื้น
        //plane.position.y = -0.5;
        plane.receiveShadow = true; // ✅ พื้นรับเงา
        scene.add(plane);
        
        //แสดงตำแหน่งแสง
        const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(lightHelper);

        // Load OBJ + Texture
        const objLoader = new THREE.OBJLoader();
        const textureLoader = new THREE.TextureLoader();
        let mesh;
        const texture = textureLoader.load('https://chotika47.github.io/myModel/material_baseColor.png');
        objLoader.load('https://chotika47.github.io/myModel/SoupPot.obj',
                function (object) {
                    mesh = object;
                    object.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: texture
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    object.position.set(0, 0, 0);
                    object.scale.set(1, 1, 1); // ปรับขนาดถ้าใหญ่/เล็กเกินไป
                    scene.add(object);

                    // ✅ GUI สำหรับปรับ intensity และตำแหน่งแสง
                    const gui = new lil.GUI();
                    const light = gui.addFolder("Light Position");
                    light.add(directionalLight, 'intensity', 0, 5).name('Light Intensity');
                    light.add(directionalLight.position, 'x', -20, 20).name('Light X');
                    light.add(directionalLight.position, 'y', -20, 20).name('Light Y');
                    light.add(directionalLight.position, 'z', -20, 20).name('Light Z');

                    const cubeFolder = gui.addFolder("Mesh Position");
                    if (mesh) {
                        // เคลื่อนที่
                        cubeFolder.add(mesh.position, 'x', -5, 5).name('Position X');
                        cubeFolder.add(mesh.position, 'y', -5, 5).name('Position Y');
                        cubeFolder.add(mesh.position, 'z', -5, 5).name('Position Z');

                        // หมุน
                        //cubeFolder.add(mesh.rotation, 'x', 0, Math.PI * 2).name('Rotate X');
                        //cubeFolder.add(mesh.rotation, 'y', 0, Math.PI * 2).name('Rotate Y');
                        //cubeFolder.add(mesh.rotation, 'z', 0, Math.PI * 2).name('Rotate Z');

                        // ขยาย/ย่อ
                        cubeFolder.add(mesh.scale, 'x', 0.1, 3).name('Scale X');
                        cubeFolder.add(mesh.scale, 'y', 0.1, 3).name('Scale Y');
                        cubeFolder.add(mesh.scale, 'z', 0.1, 3).name('Scale Z');
                    }
                },
                undefined,
                function (error) {
                    console.error('Error loading OBJ:', error);
                }
            );

        // ✅ render loop
        function animate(t) {
            //mesh.position.y = 5;
            if (mesh){
                mesh.rotation.y = (t * 0.001) * 0.5;
                //mesh.rotation.y = (t * 0.0005) * 1.5;
            }
            // mesh.position.z = Math.sin(t*0.001)*1.5;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate(0);

        window.addEventListener('keydown', (event) => {

        });

    </script>
</body>

</html>
